
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>addNewAccount: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/programmierigel/pwmanager/api/addNewAccount/handle.go (0.0%)</option>
				
				<option value="file1">github.com/programmierigel/pwmanager/api/addNewPassword/handle.go (0.0%)</option>
				
				<option value="file2">github.com/programmierigel/pwmanager/api/changepasswordname/handle.go (0.0%)</option>
				
				<option value="file3">github.com/programmierigel/pwmanager/api/changesecret/handle.go (0.0%)</option>
				
				<option value="file4">github.com/programmierigel/pwmanager/api/changeurl/handle.go (0.0%)</option>
				
				<option value="file5">github.com/programmierigel/pwmanager/api/changeusername/handle.go (0.0%)</option>
				
				<option value="file6">github.com/programmierigel/pwmanager/api/checkpassword/handle.go (0.0%)</option>
				
				<option value="file7">github.com/programmierigel/pwmanager/api/deletePassword/handle.go (0.0%)</option>
				
				<option value="file8">github.com/programmierigel/pwmanager/api/deleteaccount/handle.go (0.0%)</option>
				
				<option value="file9">github.com/programmierigel/pwmanager/api/disableSync/handle.go (0.0%)</option>
				
				<option value="file10">github.com/programmierigel/pwmanager/api/enableSync/handle.go (0.0%)</option>
				
				<option value="file11">github.com/programmierigel/pwmanager/api/getallpasswordsofaccount/handle.go (0.0%)</option>
				
				<option value="file12">github.com/programmierigel/pwmanager/api/getpassword/handle.go (0.0%)</option>
				
				<option value="file13">github.com/programmierigel/pwmanager/api/geturl/handle.go (0.0%)</option>
				
				<option value="file14">github.com/programmierigel/pwmanager/api/getusername/handle.go (0.0%)</option>
				
				<option value="file15">github.com/programmierigel/pwmanager/api/isSyncDisabled/handle.go (0.0%)</option>
				
				<option value="file16">github.com/programmierigel/pwmanager/api/ping/handle.go (0.0%)</option>
				
				<option value="file17">github.com/programmierigel/pwmanager/api/router.go (0.0%)</option>
				
				<option value="file18">github.com/programmierigel/pwmanager/api/syncToFile/handle.go (0.0%)</option>
				
				<option value="file19">github.com/programmierigel/pwmanager/api/syncfromfile/handle.go (0.0%)</option>
				
				<option value="file20">github.com/programmierigel/pwmanager/cryptography/decryptAES.go (0.0%)</option>
				
				<option value="file21">github.com/programmierigel/pwmanager/cryptography/encryptAES.go (0.0%)</option>
				
				<option value="file22">github.com/programmierigel/pwmanager/cryptography/encryptSHA256.go (0.0%)</option>
				
				<option value="file23">github.com/programmierigel/pwmanager/cryptography/generateSalt.go (0.0%)</option>
				
				<option value="file24">github.com/programmierigel/pwmanager/enviornment/getPassword.go (0.0%)</option>
				
				<option value="file25">github.com/programmierigel/pwmanager/enviornment/path.go (0.0%)</option>
				
				<option value="file26">github.com/programmierigel/pwmanager/enviornment/port.go (0.0%)</option>
				
				<option value="file27">github.com/programmierigel/pwmanager/logger/critical.go (0.0%)</option>
				
				<option value="file28">github.com/programmierigel/pwmanager/logger/debug.go (0.0%)</option>
				
				<option value="file29">github.com/programmierigel/pwmanager/logger/getLogLevel.go (0.0%)</option>
				
				<option value="file30">github.com/programmierigel/pwmanager/logger/info.go (0.0%)</option>
				
				<option value="file31">github.com/programmierigel/pwmanager/logger/isElementInSlice.go (0.0%)</option>
				
				<option value="file32">github.com/programmierigel/pwmanager/logger/terminalColor/isElementInSlice.go (0.0%)</option>
				
				<option value="file33">github.com/programmierigel/pwmanager/logger/terminalColor/setColor.go (0.0%)</option>
				
				<option value="file34">github.com/programmierigel/pwmanager/logger/warning.go (0.0%)</option>
				
				<option value="file35">github.com/programmierigel/pwmanager/main.go (0.0%)</option>
				
				<option value="file36">github.com/programmierigel/pwmanager/storage/inmemory/store.go (0.0%)</option>
				
				<option value="file37">github.com/programmierigel/pwmanager/tools/debugLog.go (0.0%)</option>
				
				<option value="file38">github.com/programmierigel/pwmanager/tools/isElementInMap.go (0.0%)</option>
				
				<option value="file39">github.com/programmierigel/pwmanager/tools/isElementInSlice.go (0.0%)</option>
				
				<option value="file40">github.com/programmierigel/pwmanager/tools/removeMapFromMap.go (0.0%)</option>
				
				<option value="file41">github.com/programmierigel/pwmanager/tools/removePasswordFromMap.go (0.0%)</option>
				
				<option value="file42">github.com/programmierigel/pwmanager/tools/removeStringFromMap.go (0.0%)</option>
				
				<option value="file43">github.com/programmierigel/pwmanager/tools/warningLog.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package addnewaccount

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to create a account. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to create a account. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">err = store.AddNewAccount(requestBody.AccountName, requestBody.Password)

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to create a account. Cant create new account.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "text/plain")
                response.WriteHeader(http.StatusOK)
                response.Header().Set("ok", "true")
                tools.DebugLog(fmt.Sprintf("Created new account ('%s').", requestBody.AccountName), request)
                response.Write([]byte(http.StatusText(http.StatusOK)))</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package addnewpassword

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to add new password. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt add new password. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">err = store.AddNewPassword(requestBody.MasterPassword, requestBody.AccountName, requestBody.PasswordName, requestBody.Password.Password, requestBody.Password.URL, requestBody.Password.Username)

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to add new password (%s) on account %s. Cant add password.", requestBody.PasswordName, requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                tools.DebugLog(fmt.Sprintf("Added new password (%s) to account %s", requestBody.PasswordName, requestBody.AccountName), request)
                response.Write([]byte(http.StatusText(http.StatusOK)))</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package changepasswordname

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to change URL. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt change URL. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">err = store.ChangePasswordName(requestBody.AccountName, requestBody.MasterPassword, requestBody.PasswordName, requestBody.NewPasswordName)

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to change URL (%s) on account %s. Cant add password.", requestBody.PasswordName, requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                tools.DebugLog(fmt.Sprintf("Changed URL (%s) on account %s", requestBody.PasswordName, requestBody.AccountName), request)
                response.Write([]byte(http.StatusText(http.StatusOK)))</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package changesecret

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to change secret. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt change secret. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">err = store.ChangePassword(requestBody.AccountName, requestBody.MasterPassword, requestBody.PasswordName, requestBody.NewSecret)

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to change secret (%s) on account %s. Cant change secret.", requestBody.PasswordName, requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                tools.DebugLog(fmt.Sprintf("Changed secret (%s) on account %s", requestBody.PasswordName, requestBody.AccountName), request)
                response.Write([]byte(http.StatusText(http.StatusOK)))</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package changeurl

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to change Username. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt change Username. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">err = store.ChangeUsername(requestBody.AccountName, requestBody.MasterPassword, requestBody.PasswordName, requestBody.NewURL)

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to change URL (%s) on account %s. Cant add password.", requestBody.PasswordName, requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                tools.DebugLog(fmt.Sprintf("Changed Username (%s) on account %s", requestBody.PasswordName, requestBody.AccountName), request)
                response.Write([]byte(http.StatusText(http.StatusOK)))</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package changeusername

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to change URL. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt change URL. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">err = store.ChangeUsername(requestBody.AccountName, requestBody.MasterPassword, requestBody.PasswordName, requestBody.NewUsername)

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to change URL (%s) on account %s. Cant add password.", requestBody.PasswordName, requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                tools.DebugLog(fmt.Sprintf("Changed URL (%s) on account %s", requestBody.PasswordName, requestBody.AccountName), request)
                response.Write([]byte(http.StatusText(http.StatusOK)))</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package checkpassword

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to check password. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt check password. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">err = store.CheckPassword(requestBody.AccountName, requestBody.MasterPassword)
                var responseBody ResponseBody
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt check password on account %s. Password is wrong. (%s)", requestBody.AccountName, requestBody.MasterPassword), err, request)
                        responseBody = ResponseBody{
                                Status: false,
                        } 
                }</span> else<span class="cov0" title="0"> {
                        responseBody = ResponseBody{
                                Status: true,
                        }
                }</span>

                <span class="cov0" title="0">responseBytes, err := json.Marshal(responseBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt check password on account %s. Cant marshal password struct. Password is correct", requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                if responseBody.Status </span><span class="cov0" title="0">{
                        tools.DebugLog(fmt.Sprintf("Checked password from account %s. Password is correct", requestBody.AccountName), request)
                }</span>
                <span class="cov0" title="0">response.Write(responseBytes)</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package deletepassword

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to delete password. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt delete password. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">err = store.DeletePassword(requestBody.MasterPassword, requestBody.AccountName, requestBody.PasswordName)

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to delete password (%s) on account %s. Cant add password.", requestBody.PasswordName, requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                tools.DebugLog(fmt.Sprintf("Deleted password (%s) on account %s", requestBody.PasswordName, requestBody.AccountName), request)
                response.Write([]byte(http.StatusText(http.StatusOK)))</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package deleteaccount

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to delete account. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt delete account. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">err = store.DeleteAccount(requestBody.AccountName, requestBody.Password)

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to delete account %s. Cant delete account.", requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                tools.DebugLog(fmt.Sprintf("Deleted account  %s", requestBody.AccountName), request)
                response.Write([]byte(http.StatusText(http.StatusOK)))</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package disablesync

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/logger"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")

                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to disable syncronization. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to disable syncronization. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">status, err := store.DisableSync(requestBody.Password)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to disable syncronization. Wrong password", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">responseBody := ResponseBody{
                        Status: status,
                }

                responseBytes, err := json.Marshal(responseBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to disable sync. Cant marshal password struct. SYNC IS STILL DISABLED", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                hostPart := fmt.Sprintf("Run by Host %s (RemoteAddr: %s,\n Proto: %s,\n Pattern: %s,\n URL: %s,\n ReqURI: %s).", request.Host, request.RemoteAddr, request.Proto, request.Pattern, request.URL, request.RequestURI)
                logger.Critiacal(fmt.Sprintf("DISABLED SYNC: %s", hostPart))
                response.Write(responseBytes)</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package enablesync

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/logger"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                // TODO: Get Admin Password from env variable and check if it is correct. Than dis/enable sync and run sync to/from file. For now the code is a comment

                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to enable syncronization. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to enable syncronization. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">status, err := store.EnableSync(requestBody.Password)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to enable syncronization. Wrong password", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">responseBody := ResponseBody{
                        Status: status,
                }

                responseBytes, err := json.Marshal(responseBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to enable sync. Cant marshal password struct. SYNC IS STILL ENABLED", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                hostPart := fmt.Sprintf("Run by Host %s (RemoteAddr: %s,\n Proto: %s,\n Pattern: %s,\n URL: %s,\n ReqURI: %s).", request.Host, request.RemoteAddr, request.Proto, request.Pattern, request.URL, request.RequestURI)
                logger.Info(fmt.Sprintf("ENABLED SYNC: %s", hostPart))
                response.Write(responseBytes)</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package getallpasswordsofaccount

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to get all passwordnames of account. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to get all passwordnames of account. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">passwordNames, err := store.GetAllPasswordNamesOfAccount(requestBody.AccountName, requestBody.MasterPassword)

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to get all passwordnames of account %s. Cant get passwords.", requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">responseBody := ResponseBody{
                        PasswordNames: passwordNames,
                }

                responseBytes, err := json.Marshal(responseBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to get all passwordnames of account %s. Cant marshal password struct.", requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                tools.DebugLog(fmt.Sprintf("Getted all passwordnames of account %s.",requestBody.AccountName), request)
                response.Write(responseBytes)</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package getpassword

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to get a password. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt get password. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">password, err := store.GetPassword(requestBody.AccountName, requestBody.MasterPassword, requestBody.PasswordName)

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to get the password (%s) on account %s. Cant get password.", requestBody.PasswordName, requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">responseBody := ResponseBody{
                        Password: password,
                }

                responseBytes, err := json.Marshal(responseBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to get the password (%s) on account %s. Cant marshal password struct.", requestBody.PasswordName, requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                tools.DebugLog(fmt.Sprintf("Getted password (%s) from account %s", requestBody.PasswordName, requestBody.AccountName), request)
                response.Write(responseBytes)</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package geturl

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to get a url. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt get url. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">url, err := store.GetURL(requestBody.AccountName, requestBody.MasterPassword, requestBody.PasswordName)

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to get the url (%s) on account %s. Cant get the url.", requestBody.PasswordName, requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">responseBody := ResponseBody{
                        URL: url,
                }

                responseBytes, err := json.Marshal(responseBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to get the url (%s) on account %s. Cant marshal url struct.", requestBody.PasswordName, requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                tools.DebugLog(fmt.Sprintf("Getted url (%s) from account %s", requestBody.PasswordName, requestBody.AccountName), request)
                response.Write(responseBytes)</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package getusername

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                response.Header().Set("Access-Control-Allow-Origin", "*")
                requestBytes, err := io.ReadAll(io.LimitReader(request.Body, 4096))
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt to get a username. Cant read request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">var requestBody RequestBody
                err = json.Unmarshal(requestBytes, &amp;requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt get username. Cant unmarshal request.", err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">username, err := store.GetUsername(requestBody.AccountName, requestBody.MasterPassword, requestBody.PasswordName)

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to get the username (%s) on account %s. Cant get the username.", requestBody.PasswordName, requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">responseBody := ResponseBody{
                        Username: username,
                }

                responseBytes, err := json.Marshal(responseBody)
                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog(fmt.Sprintf("Attempt to get the username (%s) on account %s. Cant marshal username struct.", requestBody.PasswordName, requestBody.AccountName), err, request)
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                tools.DebugLog(fmt.Sprintf("Getted username (%s) from account %s", requestBody.PasswordName, requestBody.AccountName), request)
                response.Write(responseBytes)</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package issyncdisabled

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/logger"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(response http.ResponseWriter, request *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                status := store.IsSyncDisabled()

                responseBody := ResponseBody{
                        Status: status,
                }

                responseBytes, err := json.Marshal(responseBody)
                tools.WarningLog("Attempt to get is sync disabled variable. Cant marshal password struct. SYNC IS STILL ENABLED", err, request)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(response, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">response.Header().Set("Content-Type", "application/json")
                response.WriteHeader(http.StatusOK)
                hostPart := fmt.Sprintf("Run by Host %s (RemoteAddr: %s,\n Proto: %s,\n Pattern: %s,\n URL: %s,\n ReqURI: %s).", request.Host, request.RemoteAddr, request.Proto, request.Pattern, request.URL, request.RequestURI)
                logger.Info(fmt.Sprintf("GET IF SYNC IS DISABLED: %s", hostPart))
                response.Write(responseBytes)</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package ping

import (
        "net/http"

        "github.com/julienschmidt/httprouter"
)

func Handle() httprouter.Handle <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                status := http.StatusOK

                w.WriteHeader(status)
                w.Write([]byte(http.StatusText(status)))
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package api

import (
        "github.com/julienschmidt/httprouter"
        addnewaccount "github.com/programmierigel/pwmanager/api/addNewAccount"
        addnewpassword "github.com/programmierigel/pwmanager/api/addNewPassword"
        "github.com/programmierigel/pwmanager/api/changepasswordname"
        "github.com/programmierigel/pwmanager/api/changesecret"
        changeusername "github.com/programmierigel/pwmanager/api/changeusername"
        "github.com/programmierigel/pwmanager/api/checkpassword"
        deletepassword "github.com/programmierigel/pwmanager/api/deletePassword"
        "github.com/programmierigel/pwmanager/api/deleteaccount"
        disablesync "github.com/programmierigel/pwmanager/api/disableSync"
        enablesync "github.com/programmierigel/pwmanager/api/enableSync"
        "github.com/programmierigel/pwmanager/api/getallpasswordsofaccount"
        "github.com/programmierigel/pwmanager/api/getpassword"
        "github.com/programmierigel/pwmanager/api/geturl"
        "github.com/programmierigel/pwmanager/api/getusername"
        issyncdisabled "github.com/programmierigel/pwmanager/api/isSyncDisabled"
        "github.com/programmierigel/pwmanager/api/ping"
        synctofile "github.com/programmierigel/pwmanager/api/syncToFile"
        "github.com/programmierigel/pwmanager/api/syncfromfile"
        "github.com/programmierigel/pwmanager/storage"
)

func GetRouter(store storage.Store) *httprouter.Router <span class="cov0" title="0">{
        router := httprouter.New()
        // QUERYS
        router.GET("/ping", ping.Handle())
        // COMMANDS
        router.POST("/addNewAccount", addnewaccount.Handle(store))
        router.POST("/deleteAccount", deleteaccount.Handle(store))
        router.POST("/addNewPassword", addnewpassword.Handle(store))
        router.POST("/checkPassword", checkpassword.Handle(store))
        router.POST("/deletePassword", deletepassword.Handle(store))
        router.POST("/system/disableSync", disablesync.Handle(store))
        router.POST("/system/enableSync", enablesync.Handle(store))
        router.POST("/getAllPasswordsOfAccount", getallpasswordsofaccount.Handle(store))
        router.POST("/getPassword", getpassword.Handle(store))
        router.POST("/getUsername", getusername.Handle(store))
        router.POST("/getUrl", geturl.Handle(store))
        router.POST("/changePasswordName", changepasswordname.Handle(store))
        router.POST("/changeUrl", changepasswordname.Handle(store))
        router.POST("/changeSecret", changesecret.Handle(store))
        router.POST("/changeUsername", changeusername.Handle(store))
        router.GET("/system/syncFromFile", syncfromfile.Handle(store))
        router.GET("/system/syncToFile", synctofile.Handle(store))
        router.GET("/system/isSyncDisabled", issyncdisabled.Handle(store))
        return router
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package synctofile

import (
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                err := store.SyncToFile()

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt sync cached store to file.", err, r)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">status := http.StatusOK

                w.WriteHeader(status)
                w.Write([]byte(http.StatusText(status)))</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package syncfromfile

import (
        "net/http"

        "github.com/julienschmidt/httprouter"
        "github.com/programmierigel/pwmanager/storage"
        "github.com/programmierigel/pwmanager/tools"
)

func Handle(store storage.Store) httprouter.Handle <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) </span><span class="cov0" title="0">{
                err := store.SyncFromFile()

                if err != nil </span><span class="cov0" title="0">{
                        tools.WarningLog("Attempt sync cached store from file.", err, r)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">status := http.StatusOK

                w.WriteHeader(status)
                w.Write([]byte(http.StatusText(status)))</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package cryptography

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/sha256"
        "encoding/base64"
        "errors"
)

// Decrypt decrypts a base64-encoded ciphertext using a password
// Returns the original plaintext string
func Decrypt(encryptedString, password string) (string, error) <span class="cov0" title="0">{
        // Create a hash of the password
        key := sha256.Sum256([]byte(password))

        // Create AES cipher
        block, err := aes.NewCipher(key[:])
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Create a new GCM mode
        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Decode the base64 string
        <span class="cov0" title="0">ciphertext, err := base64.StdEncoding.DecodeString(encryptedString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Check if the ciphertext is valid
        <span class="cov0" title="0">if len(ciphertext) &lt; gcm.NonceSize() </span><span class="cov0" title="0">{
                return "", errors.New("ciphertext too short")
        }</span>

        // Extract the nonce from the ciphertext
        <span class="cov0" title="0">nonce := ciphertext[:gcm.NonceSize()]
        ciphertext = ciphertext[gcm.NonceSize():]

        // Decrypt the ciphertext
        plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(plaintext), nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package cryptography

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "fmt"
        "io"

        "github.com/programmierigel/pwmanager/logger"
)

// Encrypt encrypts a plaintext string using a password
// Returns base64-encoded encrypted string
func Encrypt(plaintext, password string) (string, error) <span class="cov0" title="0">{
        // Create a hash of the password to use as the AES key
        key := sha256.Sum256([]byte(password))

        // Create AES cipher
        block, err := aes.NewCipher(key[:])
        if err != nil </span><span class="cov0" title="0">{
                logger.Critiacal(fmt.Sprintf("EncryptionAES: %s",err.Error()))
                return "", err
        }</span>

        // Create a new GCM mode
        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                logger.Critiacal(fmt.Sprintf("EncryptionAES: %s",err.Error()))
                return "", err
        }</span>

        // Generate a nonce (Number used ONCE)
        <span class="cov0" title="0">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                logger.Critiacal(fmt.Sprintf("EncryptionAES: %s",err.Error()))
                return "", err
        }</span>

        // Encrypt the plaintext
        <span class="cov0" title="0">ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)

        // Encode to base64 and return
        return base64.StdEncoding.EncodeToString(ciphertext), nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package cryptography

import (
        "crypto/sha256"
        "encoding/hex"
)

func EncryptSHA256(input string) string <span class="cov0" title="0">{
        plainText := []byte(input)
        sha256Hash := sha256.Sum256(plainText)
        return hex.EncodeToString(sha256Hash[:])
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package cryptography

import (
        "crypto/rand"
        "encoding/base64"
        "fmt"

        "github.com/programmierigel/pwmanager/logger"
)

// GenerateSalt creates a cryptographically secure random string
// suitable for use as a salt in password hashing or other security applications.
// The length parameter specifies the number of random bytes to generate
// before base64 encoding (final output will be longer).
func GenerateSalt(length int) (string, error) <span class="cov0" title="0">{
        // Allocate a byte slice to store the random bytes
        randomBytes := make([]byte, length)

        // Read random bytes from crypto/rand
        // This is a secure random number generator suitable for cryptographic use
        _, err := rand.Read(randomBytes)
        if err != nil </span><span class="cov0" title="0">{
                logger.Critiacal(fmt.Sprintf("failed to generate random bytes: %s", err.Error()))
                return "", fmt.Errorf("failed to generate random bytes: %w", err)
        }</span>

        // Encode the random bytes to base64 to get a string
        // Using RawURLEncoding to avoid characters that might need escaping in URLs
        <span class="cov0" title="0">return base64.RawURLEncoding.EncodeToString(randomBytes), nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package enviornment

import (
        "os"

        "github.com/programmierigel/pwmanager/logger"
)

func Password(defaultPassword string) string <span class="cov0" title="0">{
        password := os.Getenv("PASSWORD")

        if password == "" </span><span class="cov0" title="0">{
                logger.Info("Using default password")
                return defaultPassword
        }</span>
        <span class="cov0" title="0">logger.Critiacal("Using env password")
        return password</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package enviornment

import (
        "fmt"
        "os"

        "github.com/programmierigel/pwmanager/logger"
)

func Path(defaultPath string) string <span class="cov0" title="0">{
        path := os.Getenv("LOCATION_PATH")

        if path == "" </span><span class="cov0" title="0">{
                logger.Info(fmt.Sprintf("Path is set to default path: '%s'", defaultPath))
                return defaultPath
        }</span>

        <span class="cov0" title="0">logger.Info(fmt.Sprintf("Path is set to env path: '%s'", path))
        return path</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package enviornment

import (
        "fmt"
        "os"
        "strconv"

        "github.com/programmierigel/pwmanager/logger"
)

func Port(defaultPort int) (int, error) <span class="cov0" title="0">{
        portAsString := os.Getenv("PORT")

        if portAsString == "" </span><span class="cov0" title="0">{
                logger.Info(fmt.Sprintf("Server listen on default port %d", defaultPort))
                return defaultPort, nil
        }</span>

        <span class="cov0" title="0">port, err := strconv.Atoi(portAsString)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">fmt.Println(port)
        logger.Info(fmt.Sprintf("Server listen on env port %d", port))
        return port, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package logger

import (
        "fmt"
        "time"

        terminalcolor "github.com/programmierigel/pwmanager/logger/terminalColor"
)

func Critiacal(s string) <span class="cov0" title="0">{
        currentTime := time.Now()
        msg := fmt.Sprintf("[CRITICAL]: %s: "+s, currentTime.Format("15:04:05 - 02.01.2006"))

        fmt.Println(terminalcolor.SetColor(msg, "Red"))
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package logger

import (
        "fmt"
        "time"

        terminalcolor "github.com/programmierigel/pwmanager/logger/terminalColor"
)

func Debug(s string) <span class="cov0" title="0">{
        if GetLogLevel() != "debug" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">currentTime := time.Now()
        msg := fmt.Sprintf("[DEBUG]: %s: ***%s***", currentTime.Format("15:04:05 - 02.01.2006"), s)

        fmt.Println(terminalcolor.SetColor(msg, "Gray"))</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package logger

import (
        "os"
)

func GetLogLevel() string <span class="cov0" title="0">{
        var DefaultLogLevel = "debug"
        var PossibleLogLevels = []string{
                "debug",
                "normal",
                "critical",
        }
        env := os.Getenv("LOG_LEVEL")

        if isElementInSlice(env, PossibleLogLevels) != nil </span><span class="cov0" title="0">{
                return DefaultLogLevel
        }</span>

        <span class="cov0" title="0">return env</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package logger

import (
        "fmt"
        "time"

        terminalcolor "github.com/programmierigel/pwmanager/logger/terminalColor"
)

func Info(s string) <span class="cov0" title="0">{
        if GetLogLevel() == "critical" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">currentTime := time.Now()
        msg := fmt.Sprintf("[INFO]: %s: "+s, currentTime.Format("15:04:05 - 02.01.2006"))

        fmt.Println(terminalcolor.SetColor(msg, "Green"))</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package logger

import "fmt"

func isElementInSlice(element string, slice []string) error <span class="cov0" title="0">{
        for _, elementInSlice := range slice </span><span class="cov0" title="0">{
                if element == elementInSlice </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("element not included")</span>

}
</pre>
		
		<pre class="file" id="file32" style="display: none">package terminalcolor

import "fmt"

func isElementInSlice(element string, slice []string) error <span class="cov0" title="0">{
        for _, elementInSlice := range slice </span><span class="cov0" title="0">{
                if element == elementInSlice </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("element not included")</span>

}
</pre>
		
		<pre class="file" id="file33" style="display: none">package terminalcolor

import (
        "fmt"
)

func SetColor(s string, code string) string <span class="cov0" title="0">{
        err := isElementInSlice(code, colors)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("%s%s%s", colorsWithCodes[code], s, Reset)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package logger

import (
        "fmt"
        "time"

        terminalcolor "github.com/programmierigel/pwmanager/logger/terminalColor"
)

func Warning(s string) <span class="cov0" title="0">{
        if GetLogLevel() == "critical" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">currentTime := time.Now()
        msg := fmt.Sprintf("[WARN]: %s: "+s, currentTime.Format("15:04:05 - 02.01.2006"))

        fmt.Println(terminalcolor.SetColor(msg, "Yellow"))</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package main

import (
        "fmt"
        "net/http"

        "github.com/programmierigel/pwmanager/api"
        "github.com/programmierigel/pwmanager/enviornment"
        "github.com/programmierigel/pwmanager/storage/inmemory"
)

func main() <span class="cov0" title="0">{
        port, err := enviornment.Port(3000)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">path := enviornment.Path(".")
        password := enviornment.Password("123")

        store := inmemory.New(path, password)

        router := api.GetRouter(store)
        server := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", port),
                Handler: router,
        }

        err = server.ListenAndServe()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package inmemory

import (
        "encoding/json"
        "fmt"
        "io"
        "io/fs"
        "os"

        "github.com/programmierigel/pwmanager/cryptography"
        "github.com/programmierigel/pwmanager/logger"
        "github.com/programmierigel/pwmanager/manager"
        "github.com/programmierigel/pwmanager/tools"
)

type Store struct {
        file                string
        decryptionPasswords map[string]manager.Password
        secrets             map[string]map[string]manager.Secret
        syncDisabled        bool
        password            string
}

func New(path string, password string) *Store <span class="cov0" title="0">{

        store := &amp;Store{
                file:                path + "/secrets.json",
                decryptionPasswords: make(map[string]manager.Password),
                secrets:             make(map[string]map[string]manager.Secret),
                syncDisabled:        false,
                password:            password,
        }
        store.SyncFromFile()
        logger.Info("New Store was created")
        return store
}</span>

func (s *Store) SyncFromFile() error <span class="cov0" title="0">{
        if s.syncDisabled </span><span class="cov0" title="0">{
                logger.Critiacal("syncronization is disabled")
                return nil
        }</span>

        <span class="cov0" title="0">jsonFile, err := os.Open(s.file)

        if err != nil </span><span class="cov0" title="0">{
                logger.Critiacal("Secrets file was not found")
                return err
        }</span>

        <span class="cov0" title="0">defer jsonFile.Close()

        byteValue, _ := io.ReadAll(jsonFile)

        var secretsFile manager.SecretsFile

        err = json.Unmarshal(byteValue, &amp;secretsFile)
        if err != nil </span><span class="cov0" title="0">{
                logger.Critiacal("Content of secrets file is not compatible to JSON")
                return err
        }</span>
        <span class="cov0" title="0">s.decryptionPasswords = secretsFile.MainPasswords
        s.secrets = secretsFile.Secrets
        logger.Info("System load save from file")
        return nil</span>
}

func (s *Store) SyncToFile() error <span class="cov0" title="0">{
        if s.syncDisabled </span><span class="cov0" title="0">{
                logger.Critiacal("syncronization is disabled")
                return nil
        }</span>

        <span class="cov0" title="0">file := manager.SecretsFile{
                MainPasswords: s.decryptionPasswords,
                Secrets:       s.secrets,
        }

        parsedFile, err := json.Marshal(file)
        if err != nil </span><span class="cov0" title="0">{
                logger.Critiacal("Content of secrets file is not compatible to JSON")
                return err
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(s.file, parsedFile, fs.FileMode(0222))
        if err != nil </span><span class="cov0" title="0">{
                logger.Critiacal("Content cant saved to secrets file")
                return err
        }</span>
        <span class="cov0" title="0">logger.Info("System saved to file")
        return nil</span>

}

func (s *Store) AddNewAccount(account string, password string) error <span class="cov0" title="0">{
        salt, err := cryptography.GenerateSalt(15)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.SyncFromFile()
        if s.decryptionPasswords[account].PasswordHash != "" </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attempt to create a account that already exists (account name: %s)", account))
                return fmt.Errorf("account already exists")
        }</span>
        <span class="cov0" title="0">updatePasswordStruct := manager.Password{
                PasswordHash: cryptography.EncryptSHA256(password + salt),
                Salt:         salt,
        }

        s.decryptionPasswords[account] = updatePasswordStruct
        logger.Info(fmt.Sprintf("New Account was created with name %s", account))
        s.SyncToFile()
        return nil</span>
}

func (s *Store) DeleteAccount(account string, password string) error <span class="cov0" title="0">{
        err := s.CheckPassword(account, password)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to delete account %s account. Failed due to incorrect password.", account))
                return err
        }</span>
        <span class="cov0" title="0">s.decryptionPasswords = tools.RemovePasswordFromMap(s.decryptionPasswords, account)
        s.secrets = tools.RemoveMapFromMap(s.secrets, account)
        logger.Warning(fmt.Sprintf("Account %s was deleted", account))
        s.SyncToFile()
        return nil</span>
}

func (s *Store) CheckPassword(account string, password string) error <span class="cov0" title="0">{
        s.SyncFromFile()
        salt := s.decryptionPasswords[account].Salt
        if s.decryptionPasswords[account].PasswordHash != cryptography.EncryptSHA256(password+salt) </span><span class="cov0" title="0">{
                return fmt.Errorf("unknown password")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) AddNewPassword(masterPassword string, account string, passwordName string, passwordToAdd string, url string, username string) error <span class="cov0" title="0">{
        err := s.CheckPassword(account, masterPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to add a password (%s) on account %s. Failed due to incorrect password.", passwordName, account))
                return err
        }</span>

        <span class="cov0" title="0">if tools.IsElementInMap(passwordName, s.secrets[account]) </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to add a password (%s) on account %s but account already exists.", passwordName, account))
                return fmt.Errorf("already exists")
        }</span>
        <span class="cov0" title="0">hash, err := cryptography.Encrypt(passwordToAdd, masterPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.Critiacal(fmt.Sprintf("Cant hash password: %s", err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">if s.secrets[account] == nil </span><span class="cov0" title="0">{
                s.secrets[account] = make(map[string]manager.Secret)
        }</span>

        <span class="cov0" title="0">secretsObject := manager.Secret{
                Secret:   hash,
                URL:      url,
                Username: username,
        }

        s.secrets[account][passwordName] = secretsObject
        logger.Info(fmt.Sprintf("New password (%s) added on account %s", passwordName, account))
        s.SyncToFile()
        return nil</span>
}

func (s *Store) DeletePassword(masterPassword string, account string, passwordName string) error <span class="cov0" title="0">{
        err := s.CheckPassword(account, masterPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to delete password (%s) on account %s . Failed due to incorrect password.", passwordName, account))
                return err
        }</span>

        <span class="cov0" title="0">s.secrets[account] = tools.RemoveStringFromMap(s.secrets[account], passwordName)
        logger.Warning(fmt.Sprintf("Deleted %s password on account %s", passwordName, account))
        s.SyncToFile()
        return nil</span>
}

func (s *Store) GetPassword(account string, masterPassword string, passwordName string) (string, error) <span class="cov0" title="0">{
        err := s.CheckPassword(account, masterPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to get password %s from account %s. Failed due to incorrect password to decryption.", passwordName, account))
                return "", err
        }</span>

        <span class="cov0" title="0">if !tools.IsElementInMap(passwordName, s.secrets[account]) </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to get password %s from account %s but password doesn't exists on account", passwordName, account))
                return "", fmt.Errorf("password on account not found")
        }</span>
        <span class="cov0" title="0">defer logger.Info(fmt.Sprintf("Password to %s on account %s successfully returned", passwordName, account))

        password, err := cryptography.Decrypt(s.secrets[account][passwordName].Secret, masterPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.Critiacal(fmt.Sprintf("Cant return password: %s", err.Error()))
                return "", err
        }</span>
        <span class="cov0" title="0">return password, nil</span>
}

func (s *Store) GetURL(account string, masterPassword string, passwordName string) (string, error) <span class="cov0" title="0">{
        err := s.CheckPassword(account, masterPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to get url %s from account %s. Failed due to incorrect password.", passwordName, account))
                return "", err
        }</span>

        <span class="cov0" title="0">if !tools.IsElementInMap(passwordName, s.secrets[account]) </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to get url %s from account %s but url doesn't exists on account", passwordName, account))
                return "", fmt.Errorf("url on account not found")
        }</span>
        <span class="cov0" title="0">defer logger.Info(fmt.Sprintf("Url to %s on account %s successfully returned", passwordName, account))

        url := s.secrets[account][passwordName].URL
        return url, nil</span>
}

func (s *Store) GetUsername(account string, masterPassword string, passwordName string) (string, error) <span class="cov0" title="0">{
        err := s.CheckPassword(account, masterPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to get username %s from account %s. Failed due to incorrect password.", passwordName, account))
                return "", err
        }</span>

        <span class="cov0" title="0">if !tools.IsElementInMap(passwordName, s.secrets[account]) </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to get username %s from account %s but url doesn't exists on account", s.secrets[account][passwordName].Username, account))
                return "", fmt.Errorf("url on account not found")
        }</span>
        <span class="cov0" title="0">defer logger.Info(fmt.Sprintf("Username to %s on account %s successfully returned", passwordName, account))

        username := s.secrets[account][passwordName].Username
        return username, nil</span>
}

func (s *Store) GetAllPasswordNamesOfAccount(account string, masterPassword string) ([]string, error) <span class="cov0" title="0">{
        err := s.CheckPassword(account, masterPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to get all registered passwords from account %s. Failed due to incorrect password to decryption.", account))
                return make([]string, 0), err
        }</span>
        <span class="cov0" title="0">allPasswordNames := make([]string, 0)
        for name := range s.secrets[account] </span><span class="cov0" title="0">{
                allPasswordNames = append(allPasswordNames, name)
        }</span>
        <span class="cov0" title="0">logger.Debug(fmt.Sprintf("All PasswordNames of Account %s returned", account))
        return allPasswordNames, nil</span>

}

func (s *Store) DisableSync(password string) (bool, error) <span class="cov0" title="0">{
        if s.password != password </span><span class="cov0" title="0">{
                return s.syncDisabled, fmt.Errorf("wrong password")
        }</span>
        <span class="cov0" title="0">s.syncDisabled = true
        logger.Critiacal("!SYNC IS DISABLED!")
        return s.syncDisabled, nil</span>
}

func (s *Store) EnableSync(password string) (bool, error) <span class="cov0" title="0">{
        if s.password != password </span><span class="cov0" title="0">{
                return s.syncDisabled, fmt.Errorf("wrong password")
        }</span>
        <span class="cov0" title="0">s.syncDisabled = false
        logger.Info("SYNC IS ENABLED")
        return s.syncDisabled, nil</span>
}

func (s *Store) IsSyncDisabled() bool <span class="cov0" title="0">{
        return s.syncDisabled
}</span>

func (s *Store) ChangeUsername(account string, masterPassword string, passwordName string, newUsername string) error <span class="cov0" title="0">{
        err := s.CheckPassword(account, masterPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to change username %s from account %s to %s. Failed due to incorrect password.", s.secrets[account][passwordName].Username, account, newUsername))
                return err
        }</span>

        <span class="cov0" title="0">if !tools.IsElementInMap(passwordName, s.secrets[account]) </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to change username %s from account %s but username doesn't exists on account", passwordName, account))
                return fmt.Errorf("username on account not found")
        }</span>
        <span class="cov0" title="0">defer logger.Info(fmt.Sprintf("URL to %s on account %s successfully changed", passwordName, account))

        currentPasswordStruct := s.secrets[account][passwordName]
        s.secrets[account][passwordName] = manager.Secret{
                URL:      currentPasswordStruct.URL,
                Secret:   currentPasswordStruct.Secret,
                Username: newUsername,
        }
        return nil</span>
}

func (s *Store) ChangeURL(account string, masterPassword string, passwordName string, newURL string) error <span class="cov0" title="0">{
        err := s.CheckPassword(account, masterPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to change URL %s from account %s to %s. Failed due to incorrect password.", s.secrets[account][passwordName].URL, account, newURL))
                return err
        }</span>

        <span class="cov0" title="0">if !tools.IsElementInMap(passwordName, s.secrets[account]) </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to change url %s from account %s but url doesn't exists on account", passwordName, account))
                return fmt.Errorf("username on account not found")
        }</span>
        <span class="cov0" title="0">defer logger.Info(fmt.Sprintf("URL to %s on account %s successfully changed", passwordName, account))

        currentPasswordStruct := s.secrets[account][passwordName]
        s.secrets[account][passwordName] = manager.Secret{
                URL:      currentPasswordStruct.URL,
                Secret:   currentPasswordStruct.Secret,
                Username: newURL,
        }
        return nil</span>
}

func (s *Store) ChangePassword(account string, masterPassword string, passwordName string, newSecret string) error <span class="cov0" title="0">{
        err := s.CheckPassword(account, masterPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to change password %s from account %s to %s. Failed due to incorrect password.", s.secrets[account][passwordName].URL, account, newSecret))
                return err
        }</span>

        <span class="cov0" title="0">if !tools.IsElementInMap(passwordName, s.secrets[account]) </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to change password %s from account %s but url doesn't exists on account", passwordName, account))
                return fmt.Errorf("username on account not found")
        }</span>
        <span class="cov0" title="0">defer logger.Info(fmt.Sprintf("URL to %s on account %s successfully changed", passwordName, account))

        hash, err := cryptography.Encrypt(newSecret, masterPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.Critiacal(fmt.Sprintf("Cant hash password: %s", err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">currentPasswordStruct := s.secrets[account][passwordName]
        s.secrets[account][passwordName] = manager.Secret{
                URL:      currentPasswordStruct.URL,
                Secret:   hash,
                Username: currentPasswordStruct.Username,
        }
        return nil</span>
}

func (s *Store) ChangePasswordName(account string, masterPassword string, passwordName string, newPasswordName string) error <span class="cov0" title="0">{
        err := s.CheckPassword(account, masterPassword)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to change passwordname %s from account %s to %s. Failed due to incorrect password.", passwordName, account, newPasswordName))
                return err
        }</span>

        <span class="cov0" title="0">if tools.IsElementInMap(newPasswordName, s.secrets[account]) </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to change passwordname %s from account %s but id already exists", passwordName, account))
                return fmt.Errorf("new passwordname already exists (overwrite)")
        }</span>

        <span class="cov0" title="0">if !tools.IsElementInMap(passwordName, s.secrets[account]) </span><span class="cov0" title="0">{
                logger.Warning(fmt.Sprintf("Attemt to change passwordname %s from account %s but but passwordname doesn't exists on account", passwordName, account))
                return fmt.Errorf("passwordname on account not found")
        }</span>
        <span class="cov0" title="0">defer logger.Info(fmt.Sprintf("Passwordname to %s on account %s successfully changed", passwordName, account))

        s.secrets[account][passwordName] = s.secrets[account][newPasswordName]

        s.secrets[account] = tools.RemoveStringFromMap(s.secrets[account], newPasswordName)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package tools

import (
        "fmt"
        "net/http"

        "github.com/programmierigel/pwmanager/logger"
)

func DebugLog(s string, request *http.Request) <span class="cov0" title="0">{
        hostPart := fmt.Sprintf("Run by Host %s (RemoteAddr: %s,\n Proto: %s,\n Pattern: %s,\n URL: %s,\n ReqURI: %s).", request.Host, request.RemoteAddr, request.Proto, request.Pattern, request.URL, request.RequestURI)
        logger.Debug(fmt.Sprintf("%s\n%s", s, hostPart))
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package tools

import "github.com/programmierigel/pwmanager/manager"

func IsElementInMap(element string, mapInput map[string]manager.Secret) bool <span class="cov0" title="0">{
        for name := range mapInput </span><span class="cov0" title="0">{
                if element == name </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>

}
</pre>
		
		<pre class="file" id="file39" style="display: none">package tools

import "fmt"

func IsElementInSlice(element string, slice []string) error <span class="cov0" title="0">{
        for _, elementInSlice := range slice </span><span class="cov0" title="0">{
                if element == elementInSlice </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("element not included")</span>

}
</pre>
		
		<pre class="file" id="file40" style="display: none">package tools

import "github.com/programmierigel/pwmanager/manager"

func RemoveMapFromMap(mapToFind map[string]map[string]manager.Secret, element string) map[string]map[string]manager.Secret <span class="cov0" title="0">{
        newMap := make(map[string]map[string]manager.Secret)
        for key, value := range mapToFind</span><span class="cov0" title="0">{
                if key == element</span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">newMap[key] = value</span>
        }

        <span class="cov0" title="0">return newMap</span>

}
</pre>
		
		<pre class="file" id="file41" style="display: none">package tools

import "github.com/programmierigel/pwmanager/manager"

func RemovePasswordFromMap(mapToFind map[string]manager.Password, element string) map[string]manager.Password <span class="cov0" title="0">{
        newMap := make(map[string]manager.Password)
        for key, value := range mapToFind </span><span class="cov0" title="0">{
                if key == element </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">newMap[key] = value</span>
        }

        <span class="cov0" title="0">return newMap</span>

}
</pre>
		
		<pre class="file" id="file42" style="display: none">package tools

import "github.com/programmierigel/pwmanager/manager"

func RemoveStringFromMap(mapToFind map[string]manager.Secret, element string) map[string]manager.Secret <span class="cov0" title="0">{
        newMap := make(map[string]manager.Secret)
        for key, value := range mapToFind </span><span class="cov0" title="0">{
                if key == element </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">newMap[key] = value</span>
        }

        <span class="cov0" title="0">return newMap</span>

}
</pre>
		
		<pre class="file" id="file43" style="display: none">package tools

import (
        "fmt"
        "net/http"

        "github.com/programmierigel/pwmanager/logger"
)

func WarningLog(s string, errorMsg error, request *http.Request) <span class="cov0" title="0">{
        errorPart := fmt.Sprintf("Error: %s", errorMsg.Error())
        hostPart := fmt.Sprintf("Attemped by Host %s (RemoteAddr: %s,\n Proto: %s,\n Pattern: %s,\n URL: %s,\n ReqURI: %s).", request.Host, request.RemoteAddr, request.Proto, request.Pattern, request.URL, request.RequestURI)
        logger.Warning(fmt.Sprintf("%s\n%s\n%s ", s, errorPart, hostPart))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
